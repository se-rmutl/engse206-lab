# 6.6.2 Backend Server Code Guide - Agent Wallboard System

## üéØ ‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏°

‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á Backend Server ‡∏Ç‡∏≠‡∏á Agent Wallboard System ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ **Node.js + Express + Socket.io** ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÇ‡∏Ñ‡πâ‡∏î‡∏ó‡∏µ‡πà‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå‡πÅ‡∏•‡∏∞‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö SQLite ‡πÅ‡∏•‡∏∞ MongoDB ‡∏ï‡∏≤‡∏° schema ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏ô 6.6.4

**‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô:** 2.0 (Updated with retry logic, error handling, and rate limiting)

### üéì ‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ
- ‚úÖ ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á Backend Server ‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏à‡∏£‡∏¥‡∏á
- ‚úÖ ‡∏£‡∏π‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô databases ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏ï‡∏±‡∏ß
- ‚úÖ ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à API endpoints ‡πÅ‡∏•‡∏∞‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ
- ‚úÖ ‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à WebSocket ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö real-time communication
- ‚úÖ ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞ debug Backend ‡πÑ‡∏î‡πâ

---

## üèóÔ∏è Backend Architecture

### üìÅ Project Structure

```
backend-server/
‚îú‚îÄ‚îÄ üì¶ package.json                 # Dependencies ‡πÅ‡∏•‡∏∞ scripts
‚îú‚îÄ‚îÄ üîß .env.example                 # Environment template
‚îú‚îÄ‚îÄ üöÄ server.js                    # Main entry point
‚îÇ
‚îú‚îÄ‚îÄ ‚öôÔ∏è config/
‚îÇ   ‚îî‚îÄ‚îÄ database.js                 # Database connections (with retry)
‚îÇ
‚îú‚îÄ‚îÄ üß† models/                      # Database models
‚îÇ   ‚îú‚îÄ‚îÄ Agent.js                    # SQLite agent model
‚îÇ   ‚îú‚îÄ‚îÄ Message.js                  # MongoDB message model
‚îÇ   ‚îî‚îÄ‚îÄ Status.js                   # MongoDB status model
‚îÇ
‚îú‚îÄ‚îÄ üõ£Ô∏è routes/                      # API endpoints
‚îÇ   ‚îú‚îÄ‚îÄ auth.js                     # Authentication
‚îÇ   ‚îú‚îÄ‚îÄ agents.js                   # Agent management
‚îÇ   ‚îî‚îÄ‚îÄ messages.js                 # Message handling
‚îÇ
‚îú‚îÄ‚îÄ üîå socket/
‚îÇ   ‚îî‚îÄ‚îÄ socketHandler.js            # WebSocket events
‚îÇ
‚îî‚îÄ‚îÄ üõ°Ô∏è middleware/
    ‚îú‚îÄ‚îÄ auth.js                     # JWT authentication
    ‚îî‚îÄ‚îÄ errorHandler.js             # Error handling
```

### üîÑ Request Flow

```
Client Request ‚Üí Rate Limiter ‚Üí CORS ‚Üí Auth Middleware ‚Üí Route Handler 
‚Üí Database Model ‚Üí Database (SQLite/MongoDB) ‚Üí JSON Response
```

---

## üì¶ Setup & Installation

### Step 1: Initialize Project

```bash
# Create directory
mkdir backend-server
cd backend-server

# Initialize npm
npm init -y

# Install dependencies
npm install express socket.io sqlite3 mongoose cors dotenv jsonwebtoken express-rate-limit

# Install dev dependencies
npm install --save-dev nodemon
```

### Step 2: Create package.json

```json
{
  "name": "agent-wallboard-backend",
  "version": "2.0.0",
  "description": "Backend server for Agent Wallboard System",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "socket.io": "^4.7.2",
    "sqlite3": "^5.1.6",
    "mongoose": "^7.5.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "jsonwebtoken": "^9.0.2",
    "express-rate-limit": "^7.1.5"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}
```

### Step 3: Create .env File

```bash
# Server Configuration
PORT=3001
NODE_ENV=development

# Database Configuration
SQLITE_DB_PATH=./database/sqlite/wallboard.db
MONGODB_URI=mongodb://localhost:27017/wallboard

# JWT Configuration
JWT_SECRET=your-secret-key-change-in-production

# CORS Configuration
CORS_ORIGIN=http://localhost:3000
```

---

## üóÑÔ∏è Database Configuration

### config/database.js

```javascript
const sqlite3 = require('sqlite3').verbose();
const mongoose = require('mongoose');
const path = require('path');
const fs = require('fs');

// SQLite Configuration
const SQLITE_DB_PATH = process.env.SQLITE_DB_PATH || './database/sqlite/wallboard.db';

function initSQLite() {
  return new Promise((resolve, reject) => {
    // Calculate absolute path from project root (not from config folder)
    // Assuming server.js is in project root
    const projectRoot = path.resolve(__dirname, '../../');
    const dbPath = path.resolve(projectRoot, SQLITE_DB_PATH);
    
    console.log('üîç SQLite Connection Details:');
    console.log(`   SQLITE_DB_PATH (env): ${SQLITE_DB_PATH}`);
    console.log(`   __dirname: ${__dirname}`);
    console.log(`   Project root: ${projectRoot}`);
    console.log(`   Resolved dbPath: ${dbPath}`);
    
    // Check if directory exists
    const dbDir = path.dirname(dbPath);

    console.log(`   Resolved dbDir: ${dbDir}`);

    if (!fs.existsSync(dbDir)) {
      console.log(`‚ö†Ô∏è  Database directory does not exist: ${dbDir}`);
      console.log(`   Creating directory...`);
      try {
        fs.mkdirSync(dbDir, { recursive: true });
        console.log(`‚úÖ Directory created successfully`);
      } catch (error) {
        console.error(`‚ùå Failed to create directory:`, error);
        reject(new Error(`Failed to create database directory: ${error.message}`));
        return;
      }
    }
    
    // Check if database file exists
    if (!fs.existsSync(dbPath)) {
      console.log(`‚ö†Ô∏è  Database file does not exist: ${dbPath}`);
      console.log(`   Please run database setup script first:`);
      console.log(`   cd database/sqlite && ./setup.sh`);
      reject(new Error(`Database file not found: ${dbPath}`));
      return;
    }
    
    // Check file permissions
    try {
      fs.accessSync(dbPath, fs.constants.R_OK | fs.constants.W_OK);
      console.log(`‚úÖ Database file has correct permissions`);
    } catch (error) {
      console.error(`‚ùå Database file permission error:`, error);
      reject(new Error(`Cannot access database file: ${error.message}`));
      return;
    }
    
    // Try to open database
    const db = new sqlite3.Database(dbPath, (err) => {
      if (err) {
        console.error('‚ùå SQLite connection error:', err);
        reject(err);
      } else {
        console.log('‚úÖ Connected to SQLite database');
        console.log(`üìÅ Database location: ${dbPath}`);
        
        // Test query
        db.get("SELECT COUNT(*) as count FROM agents", (err, row) => {
          if (err) {
            console.error('‚ùå Database query error:', err);
            console.log('‚ö†Ô∏è  Database file exists but schema might be missing');
            db.close();
            reject(new Error('Database schema error - please run setup script'));
          } else {
            console.log(`üìä Found ${row.count} agents in database`);
            db.close();
            resolve();
          }
        });
      }
    });
  });
}

// MongoDB Configuration with Retry Logic
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/wallboard';

async function connectMongoDB() {
  const maxRetries = 5;
  let currentRetry = 0;
  
  while (currentRetry < maxRetries) {
    try {
      await mongoose.connect(MONGODB_URI, {
        useNewUrlParser: true,
        useUnifiedTopology: true,
        serverSelectionTimeoutMS: 5000
      });
      console.log('‚úÖ Connected to MongoDB');
      console.log(`üìÅ Database: ${MONGODB_URI}`);
      return;
      
    } catch (error) {
      currentRetry++;
      console.error(`‚ùå MongoDB connection attempt ${currentRetry}/${maxRetries} failed:`, error.message);
      
      if (currentRetry >= maxRetries) {
        console.error('‚ùå All MongoDB connection attempts failed');
        throw new Error(`MongoDB connection failed after ${maxRetries} attempts: ${error.message}`);
      }
      
      const waitTime = Math.min(1000 * Math.pow(2, currentRetry), 10000);
      console.log(`‚è≥ Waiting ${waitTime/1000}s before retry...`);
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
  }
}

// MongoDB connection event handlers
mongoose.connection.on('connected', () => {
  console.log('üìä Mongoose connected to MongoDB');
});

mongoose.connection.on('error', (err) => {
  console.error('‚ùå Mongoose connection error:', err);
});

mongoose.connection.on('disconnected', () => {
  console.log('‚ö†Ô∏è  Mongoose disconnected from MongoDB');
});

// Graceful shutdown
process.on('SIGINT', async () => {
  await mongoose.connection.close();
  console.log('üîå MongoDB connection closed due to app termination');
  process.exit(0);
});

// Export functions
module.exports = {
  initSQLite,
  connectMongoDB,
  // Export resolved path for use in models
  getSQLitePath: () => {
    const projectRoot = path.resolve(__dirname, '../../');
    return path.resolve(projectRoot, SQLITE_DB_PATH);
  }
};
```

---

## üß† Database Models

### models/Agent.js (SQLite)

```javascript
const sqlite3 = require('sqlite3').verbose();
const path = require('path');

// ‚úÖ Import the path getter function
const { getSQLitePath } = require('../config/database');

class Agent {
  static getDbPath() {
    // Use the centralized path resolution
    return getSQLitePath();
  }

  static findByCode(agentCode) {
    return new Promise((resolve, reject) => {
      const dbPath = Agent.getDbPath();
      
      const db = new sqlite3.Database(dbPath, (err) => {
        if (err) {
          console.error(`‚ùå Error opening database for agent ${agentCode}:`, err);
          reject(new Error(`Database connection failed: ${err.message}`));
          return;
        }
      });
      
      const query = `
        SELECT 
          a.agent_id,
          a.agent_code,
          a.agent_name,
          a.team_id,
          a.role,
          a.email,
          a.phone,
          a.hire_date,
          a.is_active,
          t.team_name
        FROM agents a
        LEFT JOIN teams t ON a.team_id = t.team_id
        WHERE a.agent_code = ? AND a.is_active = 1
      `;
      
      db.get(query, [agentCode.toUpperCase()], (err, row) => {
        if (err) {
          console.error(`‚ùå Error finding agent ${agentCode}:`, err);
          db.close();
          reject(new Error(`Query failed: ${err.message}`));
        } else {
          db.close();
          resolve(row || null);
        }
      });
    });
  }

  /**
   * Find all agents in a team
   * @param {number} teamId - Team ID
   * @returns {Promise<Array>} Array of agent objects
   */
  static findByTeam(teamId) {
    return new Promise((resolve, reject) => {
      const dbPath = Agent.getDbPath();
      const db = new sqlite3.Database(dbPath, (err) => {
        if (err) {
          console.error(`‚ùå Error opening database for team ${teamId}:`, err);
          reject(new Error(`Database connection failed: ${err.message}`));
          return;
        }
      });
      
      const query = `
        SELECT 
          agent_code,
          agent_name,
          role,
          email,
          phone
        FROM agents
        WHERE team_id = ? AND is_active = 1 AND role = 'agent'
        ORDER BY agent_name
      `;
      
      db.all(query, [teamId], (err, rows) => {
        if (err) {
          console.error(`‚ùå Error finding team ${teamId} agents:`, err);
          db.close();
          reject(new Error(`Query failed: ${err.message}`));
        } else {
          db.close();
          resolve(rows || []);
        }
      });
    });
  }

  /**
   * Get all active agents
   * @returns {Promise<Array>} Array of all agents
   */
  static findAll() {
    return new Promise((resolve, reject) => {
      const dbPath = Agent.getDbPath();      
      const db = new sqlite3.Database(dbPath, (err) => {
        if (err) {
          console.error('‚ùå Error opening database:', err);
          reject(new Error(`Database connection failed: ${err.message}`));
          return;
        }
      });
      
      const query = `
        SELECT 
          a.agent_code,
          a.agent_name,
          a.team_id,
          a.role,
          t.team_name
        FROM agents a
        LEFT JOIN teams t ON a.team_id = t.team_id
        WHERE a.is_active = 1
        ORDER BY a.role DESC, a.agent_name
      `;
      
      db.all(query, [], (err, rows) => {
        if (err) {
          console.error('‚ùå Error finding all agents:', err);
          db.close();
          reject(new Error(`Query failed: ${err.message}`));
        } else {
          db.close();
          resolve(rows || []);
        }
      });
    });
  }
}

module.exports = Agent;
```

### models/Message.js (MongoDB)

```javascript
const mongoose = require('mongoose');

const messageSchema = new mongoose.Schema({
  fromCode: {
    type: String,
    required: true,
    uppercase: true,
    index: true
  },
  toCode: {
    type: String,
    uppercase: true,
    index: true
  },
  toTeamId: {
    type: Number,
    index: true
  },
  content: {
    type: String,
    required: true,
    trim: true,
    maxlength: 500
  },
  type: {
    type: String,
    enum: ['direct', 'broadcast'],
    required: true
  },
  priority: {
    type: String,
    enum: ['low', 'normal', 'high'],
    default: 'normal'
  },
  isRead: {
    type: Boolean,
    default: false
  },
  readAt: {
    type: Date
  },
  timestamp: {
    type: Date,
    default: Date.now,
    index: true
  }
}, {
  collection: 'messages',
  timestamps: true
});

// Compound indexes for efficient queries
messageSchema.index({ toCode: 1, timestamp: -1 });
messageSchema.index({ toTeamId: 1, timestamp: -1 });
messageSchema.index({ fromCode: 1, timestamp: -1 });

module.exports = mongoose.model('Message', messageSchema);
```

### models/Status.js (MongoDB)

```javascript
const mongoose = require('mongoose');

const statusSchema = new mongoose.Schema({
  agentCode: {
    type: String,
    required: true,
    uppercase: true,
    index: true
  },
  status: {
    type: String,
    enum: ['Available', 'Busy', 'Break', 'Offline'],
    required: true
  },
  timestamp: {
    type: Date,
    default: Date.now,
    index: true
  },
  teamId: {
    type: Number,
    index: true
  },
  duration: {
    type: Number
  },
  sessionId: {
    type: String
  }
}, {
  collection: 'agent_status',
  timestamps: true
});

// Compound indexes
statusSchema.index({ agentCode: 1, timestamp: -1 });
statusSchema.index({ teamId: 1, timestamp: -1 });

module.exports = mongoose.model('Status', statusSchema);
```

---

## üõ£Ô∏è API Routes

### routes/auth.js

```javascript
const express = require('express');
const jwt = require('jsonwebtoken');
const router = express.Router();
const Agent = require('../models/Agent');

const JWT_SECRET = process.env.JWT_SECRET || 'default-secret-change-me';

/**
 * POST /api/auth/login
 * Agent/Supervisor login
 */
router.post('/login', async (req, res) => {
  try {
    const { agentCode, supervisorCode } = req.body;
    
    // Determine login type
    const code = (agentCode || supervisorCode || '').toUpperCase();
    
    if (!code) {
      return res.status(400).json({
        success: false,
        error: 'Agent code or Supervisor code is required'
      });
    }
    
    // Find user
    const user = await Agent.findByCode(code);
    
    if (!user) {
      return res.status(401).json({
        success: false,
        error: 'Invalid credentials'
      });
    }
    
    // For supervisors, get team members
    let teamData = null;
    if (user.role === 'supervisor') {
      teamData = await Agent.findByTeam(user.team_id);
    }
    
    // Generate JWT token
    const token = jwt.sign(
      {
        agentCode: user.agent_code,
        role: user.role,
        teamId: user.team_id
      },
      JWT_SECRET,
      { expiresIn: '8h' }
    );
    
    // Response
    res.json({
      success: true,
      data: {
        user: {
          agentCode: user.agent_code,
          agentName: user.agent_name,
          teamId: user.team_id,
          teamName: user.team_name,
          role: user.role,
          email: user.email
        },
        teamData: teamData,
        token: token
      }
    });
    
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});

/**
 * POST /api/auth/logout
 * User logout
 */
router.post('/logout', (req, res) => {
  res.json({
    success: true,
    message: 'Logged out successfully'
  });
});

module.exports = router;
```

### routes/agents.js

```javascript
const express = require('express');
const router = express.Router();
const Agent = require('../models/Agent');
const Status = require('../models/Status');
const authMiddleware = require('../middleware/auth');

/**
 * GET /api/agents/team/:teamId
 * Get all agents in a team (for supervisors)
 */
router.get('/team/:teamId', authMiddleware, async (req, res) => {
  try {
    const { teamId } = req.params;
    
    const agents = await Agent.findByTeam(parseInt(teamId));
    
    res.json({
      success: true,
      teamId: parseInt(teamId),
      agents: agents,
      count: agents.length
    });
    
  } catch (error) {
    console.error('Get team agents error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get team agents'
    });
  }
});

/**
 * PUT /api/agents/:agentCode/status
 * Update agent status
 */
router.put('/:agentCode/status', authMiddleware, async (req, res) => {
  try {
    const { agentCode } = req.params;
    const { status } = req.body;
    
    // Validate status
    const validStatuses = ['Available', 'Busy', 'Break', 'Offline'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({
        success: false,
        error: `Invalid status. Must be one of: ${validStatuses.join(', ')}`
      });
    }
    
    // Verify agent exists
    const agent = await Agent.findByCode(agentCode.toUpperCase());
    if (!agent) {
      return res.status(404).json({
        success: false,
        error: 'Agent not found'
      });
    }
    
    // Save status to MongoDB
    const statusUpdate = await Status.create({
      agentCode: agentCode.toUpperCase(),
      status: status,
      timestamp: new Date(),
      teamId: agent.team_id
    });
    
    res.json({
      success: true,
      data: {
        agentCode: agentCode.toUpperCase(),
        status: status,
        timestamp: statusUpdate.timestamp,
        teamId: agent.team_id
      }
    });
    
  } catch (error) {
    console.error('Update status error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to update status'
    });
  }
});

/**
 * GET /api/agents/:agentCode/history
 * Get agent status history
 */
router.get('/:agentCode/history', authMiddleware, async (req, res) => {
  try {
    const { agentCode } = req.params;
    const { limit = 50 } = req.query;
    
    const history = await Status.find({
      agentCode: agentCode.toUpperCase()
    })
    .sort({ timestamp: -1 })
    .limit(parseInt(limit))
    .lean();
    
    res.json({
      success: true,
      agentCode: agentCode.toUpperCase(),
      history: history,
      count: history.length
    });
    
  } catch (error) {
    console.error('Get history error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get agent history'
    });
  }
});

module.exports = router;
```

### routes/messages.js

```javascript
const express = require('express');
const router = express.Router();
const Message = require('../models/Message');
const Agent = require('../models/Agent');
const authMiddleware = require('../middleware/auth');

/**
 * POST /api/messages/send
 * Send a message (direct or broadcast)
 */
router.post('/send', authMiddleware, async (req, res) => {
  try {
    const { fromCode, toCode, toTeamId, content, type, priority } = req.body;
    
    // Validate required fields
    if (!fromCode || !content || !type) {
      return res.status(400).json({
        success: false,
        error: 'fromCode, content, and type are required'
      });
    }
    
    // Validate message type
    if (!['direct', 'broadcast'].includes(type)) {
      return res.status(400).json({
        success: false,
        error: 'type must be either "direct" or "broadcast"'
      });
    }
    
    // Validate recipients
    if (type === 'direct' && !toCode) {
      return res.status(400).json({
        success: false,
        error: 'toCode is required for direct messages'
      });
    }
    
    if (type === 'broadcast' && !toTeamId) {
      return res.status(400).json({
        success: false,
        error: 'toTeamId is required for broadcast messages'
      });
    }
    
    // Create message
    const messageData = {
      fromCode: fromCode.toUpperCase(),
      content: content.trim(),
      type: type,
      priority: priority || 'normal',
      timestamp: new Date(),
      isRead: false
    };
    
    if (type === 'direct') {
      messageData.toCode = toCode.toUpperCase();
    } else {
      messageData.toTeamId = parseInt(toTeamId);
    }
    
    const message = await Message.create(messageData);
    
    res.json({
      success: true,
      data: {
        messageId: message._id,
        fromCode: message.fromCode,
        type: message.type,
        timestamp: message.timestamp,
        ...(message.toCode && { toCode: message.toCode }),
        ...(message.toTeamId && { toTeamId: message.toTeamId })
      }
    });
    
  } catch (error) {
    console.error('Send message error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to send message'
    });
  }
});

/**
 * GET /api/messages/agent/:agentCode
 * Get messages for an agent
 */
router.get('/agent/:agentCode', authMiddleware, async (req, res) => {
  try {
    const { agentCode } = req.params;
    const { limit = 50, unreadOnly = false } = req.query;
    
    // Get agent info for team
    const agent = await Agent.findByCode(agentCode.toUpperCase());
    if (!agent) {
      return res.status(404).json({
        success: false,
        error: 'Agent not found'
      });
    }
    
    // Build query
    const query = {
      $or: [
        { toCode: agentCode.toUpperCase() },
        { toTeamId: agent.team_id }
      ]
    };
    
    if (unreadOnly === 'true') {
      query.isRead = false;
    }
    
    const messages = await Message.find(query)
      .sort({ timestamp: -1 })
      .limit(parseInt(limit))
      .lean();
    
    res.json({
      success: true,
      agentCode: agentCode.toUpperCase(),
      messages: messages,
      count: messages.length
    });
    
  } catch (error) {
    console.error('Get messages error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get messages'
    });
  }
});

/**
 * PUT /api/messages/:messageId/read
 * Mark message as read
 */
router.put('/:messageId/read', authMiddleware, async (req, res) => {
  try {
    const { messageId } = req.params;
    
    const message = await Message.findByIdAndUpdate(
      messageId,
      { isRead: true, readAt: new Date() },
      { new: true }
    );
    
    if (!message) {
      return res.status(404).json({
        success: false,
        error: 'Message not found'
      });
    }
    
    res.json({
      success: true,
      data: {
        messageId: message._id,
        isRead: message.isRead,
        readAt: message.readAt
      }
    });
    
  } catch (error) {
    console.error('Mark read error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to mark message as read'
    });
  }
});

module.exports = router;
```

---

## üîå WebSocket Handler

### socket/socketHandler.js

```javascript
const Message = require('../models/Message');
const Status = require('../models/Status');

// Track active connections
const activeConnections = new Map(); // agentCode -> socketId
const supervisorConnections = new Map(); // supervisorCode -> socketId

function socketHandler(io) {
  console.log('‚ö° WebSocket server initialized');
  
  io.on('connection', (socket) => {
    console.log('üîå New client connected:', socket.id);
    
    /**
     * Agent Connection
     */
    socket.on('agent_connect', (data) => {
      try {
        const { agentCode } = data;
        
        if (!agentCode) {
          socket.emit('connection_error', { message: 'Agent code required' });
          return;
        }
        
        const cleanCode = agentCode.toUpperCase();
        
        // Store connection
        activeConnections.set(cleanCode, socket.id);
        socket.agentCode = cleanCode;
        socket.userType = 'agent';
        
        console.log(`üë§ Agent ${cleanCode} connected`);
        
        // Notify supervisors
        socket.broadcast.emit('agent_connected', {
          agentCode: cleanCode,
          timestamp: new Date()
        });
        
        socket.emit('connection_success', {
          agentCode: cleanCode,
          status: 'connected'
        });
        
      } catch (error) {
        console.error('Agent connect error:', error);
        socket.emit('connection_error', { message: 'Connection failed' });
      }
    });
    
    /**
     * Supervisor Connection
     */
    socket.on('supervisor_connect', (data) => {
      try {
        const { supervisorCode } = data;
        
        if (!supervisorCode) {
          socket.emit('connection_error', { message: 'Supervisor code required' });
          return;
        }
        
        const cleanCode = supervisorCode.toUpperCase();
        
        // Store connection
        supervisorConnections.set(cleanCode, socket.id);
        socket.supervisorCode = cleanCode;
        socket.userType = 'supervisor';
        
        console.log(`üë®‚Äçüíº Supervisor ${cleanCode} connected`);
        
        socket.emit('connection_success', {
          supervisorCode: cleanCode,
          status: 'connected'
        });
        
      } catch (error) {
        console.error('Supervisor connect error:', error);
        socket.emit('connection_error', { message: 'Connection failed' });
      }
    });
    
    /**
     * Status Update
     */
    socket.on('update_status', async (data) => {
      try {
        const { agentCode, status } = data;
        
        if (!agentCode || !status) {
          socket.emit('status_error', { message: 'agentCode and status required' });
          return;
        }
        
        // Save to MongoDB
        const statusUpdate = await Status.create({
          agentCode: agentCode.toUpperCase(),
          status: status,
          timestamp: new Date()
        });
        
        // Broadcast to all supervisors
        socket.broadcast.emit('agent_status_update', {
          agentCode: agentCode.toUpperCase(),
          status: status,
          timestamp: statusUpdate.timestamp
        });
        
        // Confirm to agent
        socket.emit('status_updated', {
          agentCode: agentCode.toUpperCase(),
          status: status,
          timestamp: statusUpdate.timestamp
        });
        
        console.log(`üìä ${agentCode} status: ${status}`);
        
      } catch (error) {
        console.error('Status update error:', error);
        socket.emit('status_error', { message: 'Failed to update status' });
      }
    });
    
    /**
     * Send Message
     */
    socket.on('send_message', async (data) => {
      try {
        const { fromCode, toCode, toTeamId, content, type } = data;
        
        // Save to MongoDB
        const messageData = {
          fromCode: fromCode.toUpperCase(),
          content: content,
          type: type || 'direct',
          timestamp: new Date(),
          isRead: false
        };
        
        if (type === 'direct' && toCode) {
          messageData.toCode = toCode.toUpperCase();
        } else if (type === 'broadcast' && toTeamId) {
          messageData.toTeamId = parseInt(toTeamId);
        }
        
        const message = await Message.create(messageData);
        
        // Send to recipient(s)
        if (type === 'direct' && toCode) {
          const targetSocketId = activeConnections.get(toCode.toUpperCase());
          if (targetSocketId) {
            io.to(targetSocketId).emit('new_message', {
              messageId: message._id,
              fromCode: message.fromCode,
              content: message.content,
              timestamp: message.timestamp,
              type: 'direct'
            });
          }
        } else if (type === 'broadcast') {
          socket.broadcast.emit('new_message', {
            messageId: message._id,
            fromCode: message.fromCode,
            content: message.content,
            timestamp: message.timestamp,
            type: 'broadcast',
            toTeamId: toTeamId
          });
        }
        
        // Confirm to sender
        socket.emit('message_sent', {
          messageId: message._id,
          status: 'delivered'
        });
        
        console.log(`üí¨ Message from ${fromCode} (${type})`);
        
      } catch (error) {
        console.error('Send message error:', error);
        socket.emit('message_error', { message: 'Failed to send message' });
      }
    });
    
    /**
     * Disconnect
     */
    socket.on('disconnect', () => {
      try {
        console.log(`üîå Client disconnected: ${socket.id}`);
        
        if (socket.agentCode) {
          activeConnections.delete(socket.agentCode);
          
          socket.broadcast.emit('agent_disconnected', {
            agentCode: socket.agentCode,
            timestamp: new Date()
          });
          
          console.log(`üë§ Agent ${socket.agentCode} disconnected`);
        }
        
        if (socket.supervisorCode) {
          supervisorConnections.delete(socket.supervisorCode);
          console.log(`üë®‚Äçüíº Supervisor ${socket.supervisorCode} disconnected`);
        }
        
      } catch (error) {
        console.error('Disconnect error:', error);
      }
    });
  });
}

module.exports = socketHandler;
```

---

## üõ°Ô∏è Middleware

### middleware/auth.js

```javascript
const jwt = require('jsonwebtoken');

const JWT_SECRET = process.env.JWT_SECRET || 'default-secret-change-me';

function authMiddleware(req, res, next) {
  try {
    // Get token from header
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        success: false,
        error: 'No token provided'
      });
    }
    
    const token = authHeader.substring(7); // Remove 'Bearer '
    
    // Verify token
    const decoded = jwt.verify(token, JWT_SECRET);
    
    // Add user info to request
    req.user = {
      agentCode: decoded.agentCode,
      role: decoded.role,
      teamId: decoded.teamId
    };
    
    next();
    
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({
        success: false,
        error: 'Token expired'
      });
    }
    
    return res.status(401).json({
      success: false,
      error: 'Invalid token'
    });
  }
}

module.exports = authMiddleware;
```

### middleware/errorHandler.js

```javascript
function errorHandler(err, req, res, next) {
  console.error('Error:', err);
  
  // Mongoose validation error
  if (err.name === 'ValidationError') {
    const messages = Object.values(err.errors).map(e => e.message);
    return res.status(400).json({
      success: false,
      error: 'Validation failed',
      details: messages
    });
  }
  
  // Mongoose duplicate key error
  if (err.code === 11000) {
    return res.status(400).json({
      success: false,
      error: 'Duplicate field value'
    });
  }
  
  // JWT errors
  if (err.name === 'JsonWebTokenError') {
    return res.status(401).json({
      success: false,
      error: 'Invalid token'
    });
  }
  
  // Default error
  res.status(500).json({
    success: false,
    error: 'Internal server error'
  });
}

module.exports = errorHandler;
```

---

## üöÄ Main Server File

### server.js

```javascript
const express = require('express');
const http = require('http');
const socketio = require('socket.io');
const cors = require('cors');
const rateLimit = require('express-rate-limit');
require('dotenv').config();

// Import configurations
const { initSQLite, connectMongoDB } = require('./config/database');

// Import routes
const authRoutes = require('./routes/auth');
const agentRoutes = require('./routes/agents');
const messageRoutes = require('./routes/messages');

// Import socket handler
const socketHandler = require('./socket/socketHandler');

// Import middleware
const errorHandler = require('./middleware/errorHandler');

// Initialize Express
const app = express();
const server = http.createServer(app);

// CORS configuration
const corsOptions = {
  origin: process.env.CORS_ORIGIN || 'http://localhost:3000',
  credentials: true
};

app.use(cors(corsOptions));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Rate Limiting
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: {
    success: false,
    error: 'Too many requests from this IP, please try again later.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Apply rate limiting to all API routes
app.use('/api/', apiLimiter);

// Stricter rate limiting for auth endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 10,
  message: {
    success: false,
    error: 'Too many login attempts, please try again later.'
  }
});

app.use('/api/auth/', authLimiter);

// Request logging
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  next();
});

// API Routes
app.use('/api/auth', authRoutes);
app.use('/api/agents', agentRoutes);
app.use('/api/messages', messageRoutes);

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    memory: {
      used: `${Math.round(process.memoryUsage().heapUsed / 1024 / 1024)}MB`,
      total: `${Math.round(process.memoryUsage().heapTotal / 1024 / 1024)}MB`
    }
  });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({
    success: false,
    error: 'Route not found'
  });
});

// Error handler
app.use(errorHandler);

// WebSocket setup
const io = socketio(server, {
  cors: corsOptions
});

socketHandler(io);

// Database initialization and server start
async function startServer() {
  try {
    console.log('üöÄ Starting Agent Wallboard Backend Server...');
    console.log('');
    
    // Initialize databases
    console.log('üìä Initializing databases...');
    await initSQLite();
    await connectMongoDB();
    console.log('');
    
    // Start server
    const PORT = process.env.PORT || 3001;
    server.listen(PORT, () => {
      console.log('‚úÖ Server started successfully!');
      console.log('');
      console.log(`üì° HTTP Server: http://localhost:${PORT}`);
      console.log(`‚ö° WebSocket Server: ws://localhost:${PORT}`);
      console.log(`üè• Health Check: http://localhost:${PORT}/health`);
      console.log('');
      console.log('üìã Available Routes:');
      console.log('   POST   /api/auth/login');
      console.log('   POST   /api/auth/logout');
      console.log('   GET    /api/agents/team/:teamId');
      console.log('   PUT    /api/agents/:agentCode/status');
      console.log('   GET    /api/agents/:agentCode/history');
      console.log('   POST   /api/messages/send');
      console.log('   GET    /api/messages/agent/:agentCode');
      console.log('   PUT    /api/messages/:messageId/read');
      console.log('');
      console.log('üîå WebSocket Events:');
      console.log('   Client ‚Üí Server:');
      console.log('     - agent_connect');
      console.log('     - supervisor_connect');
      console.log('     - update_status');
      console.log('     - send_message');
      console.log('   Server ‚Üí Client:');
      console.log('     - connection_success');
      console.log('     - agent_status_update');
      console.log('     - new_message');
      console.log('');
      console.log('üõ°Ô∏è  Rate Limiting:');
      console.log('   - API: 100 requests / 15 min');
      console.log('   - Auth: 10 requests / 15 min');
      console.log('');
      console.log('Press Ctrl+C to stop');
    });
    
  } catch (error) {
    console.error('‚ùå Failed to start server:', error);
    process.exit(1);
  }
}

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('\nüõë Shutting down gracefully...');
  server.close(() => {
    console.log('‚úÖ Server closed');
    process.exit(0);
  });
});

// Start the server
startServer();

module.exports = { app, io };
```

---

## üß™ Testing Guide

### Testing with curl

**1. Health Check:**
```bash
curl http://localhost:3001/health
```

**2. Agent Login:**
```bash
curl -X POST http://localhost:3001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "agentCode": "AG001"
  }'
```

**3. Supervisor Login:**
```bash
curl -X POST http://localhost:3001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "supervisorCode": "SP001"
  }'
```

**4. Update Agent Status:**
```bash
# Save token from login response
TOKEN="your-jwt-token-here"

curl -X PUT http://localhost:3001/api/agents/AG001/status \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{
    "status": "Busy"
  }'
```

**5. Send Direct Message:**
```bash
curl -X POST http://localhost:3001/api/messages/send \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{
    "fromCode": "SP001",
    "toCode": "AG001",
    "content": "Please check your queue",
    "type": "direct",
    "priority": "normal"
  }'
```

**6. Get Agent Messages:**
```bash
curl -X GET http://localhost:3001/api/messages/agent/AG001 \
  -H "Authorization: Bearer $TOKEN"
```

### Testing Script (test-api.sh)

```bash
#!/bin/bash

BASE_URL="http://localhost:3001"

echo "üß™ Testing Backend API..."
echo ""

# Test 1: Health Check
echo "1. Health Check"
curl -s $BASE_URL/health | jq '.'
echo ""

# Test 2: Agent Login
echo "2. Agent Login"
RESPONSE=$(curl -s -X POST $BASE_URL/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"agentCode": "AG001"}')
echo $RESPONSE | jq '.'

TOKEN=$(echo $RESPONSE | jq -r '.data.token')
echo "Token: $TOKEN"
echo ""

# Test 3: Update Status
echo "3. Update Status"
curl -s -X PUT $BASE_URL/api/agents/AG001/status \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"status": "Busy"}' | jq '.'
echo ""

# Test 4: Get Status History
echo "4. Get Status History"
curl -s -X GET $BASE_URL/api/agents/AG001/history \
  -H "Authorization: Bearer $TOKEN" | jq '.'
echo ""

# Test 5: Supervisor Login
echo "5. Supervisor Login"
SUPER_RESPONSE=$(curl -s -X POST $BASE_URL/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"supervisorCode": "SP001"}')
echo $SUPER_RESPONSE | jq '.'

SUPER_TOKEN=$(echo $SUPER_RESPONSE | jq -r '.data.token')
echo ""

# Test 6: Get Team Members
echo "6. Get Team Members"
curl -s -X GET $BASE_URL/api/agents/team/1 \
  -H "Authorization: Bearer $SUPER_TOKEN" | jq '.'
echo ""

# Test 7: Send Message
echo "7. Send Message"
curl -s -X POST $BASE_URL/api/messages/send \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $SUPER_TOKEN" \
  -d '{
    "fromCode": "SP001",
    "toCode": "AG001",
    "content": "Test message",
    "type": "direct",
    "priority": "normal"
  }' | jq '.'
echo ""

echo "‚úÖ API Testing completed!"
```

### WebSocket Testing (test-websocket.js)

```javascript
const io = require('socket.io-client');

const SOCKET_URL = 'http://localhost:3001';

console.log('üß™ Testing WebSocket Connection...\n');

// Create agent connection
const agentSocket = io(SOCKET_URL);

agentSocket.on('connect', () => {
  console.log('‚úÖ Agent connected:', agentSocket.id);
  
  // Authenticate as agent
  agentSocket.emit('agent_connect', { agentCode: 'AG001' });
});

agentSocket.on('connection_success', (data) => {
  console.log('‚úÖ Agent authenticated:', data);
  
  // Test status update
  console.log('\nüìä Testing status update...');
  agentSocket.emit('update_status', {
    agentCode: 'AG001',
    status: 'Available'
  });
});

agentSocket.on('status_updated', (data) => {
  console.log('‚úÖ Status updated:', data);
});

agentSocket.on('new_message', (message) => {
  console.log('üí¨ New message received:', message);
});

agentSocket.on('connection_error', (error) => {
  console.error('‚ùå Connection error:', error);
});

// Create supervisor connection
setTimeout(() => {
  console.log('\nüë®‚Äçüíº Creating supervisor connection...');
  const supervisorSocket = io(SOCKET_URL);
  
  supervisorSocket.on('connect', () => {
    console.log('‚úÖ Supervisor connected:', supervisorSocket.id);
    
    supervisorSocket.emit('supervisor_connect', { supervisorCode: 'SP001' });
  });
  
  supervisorSocket.on('connection_success', (data) => {
    console.log('‚úÖ Supervisor authenticated:', data);
    
    // Test sending message
    console.log('\nüí¨ Testing send message...');
    supervisorSocket.emit('send_message', {
      fromCode: 'SP001',
      toCode: 'AG001',
      content: 'Test message from WebSocket',
      type: 'direct'
    });
  });
  
  supervisorSocket.on('message_sent', (data) => {
    console.log('‚úÖ Message sent:', data);
    
    // Cleanup
    setTimeout(() => {
      console.log('\nüõë Closing connections...');
      agentSocket.close();
      supervisorSocket.close();
      process.exit(0);
    }, 2000);
  });
  
  supervisorSocket.on('agent_status_update', (data) => {
    console.log('üìä Status update received:', data);
  });
  
}, 2000);
```

---

## ‚úÖ Verification Checklist

### üìã Backend Verification

**Database Connection:**
- [ ] SQLite database file exists and is accessible
- [ ] MongoDB service is running
- [ ] Both databases connect successfully on server start
- [ ] Retry logic works when MongoDB is temporarily unavailable

**API Endpoints:**
- [ ] POST /api/auth/login returns token for valid credentials
- [ ] PUT /api/agents/:code/status updates and saves to MongoDB
- [ ] GET /api/agents/team/:teamId returns correct team members
- [ ] POST /api/messages/send creates message in MongoDB
- [ ] GET /api/messages/agent/:code returns messages correctly

**Rate Limiting:**
- [ ] API rate limit (100/15min) works
- [ ] Auth rate limit (10/15min) works
- [ ] Rate limit responses include appropriate headers

**WebSocket:**
- [ ] Agents can connect and authenticate
- [ ] Supervisors can connect and authenticate
- [ ] Status updates broadcast to connected clients
- [ ] Messages deliver to correct recipients
- [ ] Disconnect events handled properly

**Error Handling:**
- [ ] Invalid credentials return 401 error
- [ ] Missing auth token returns 401 error
- [ ] Invalid data returns 400 error with details
- [ ] Server errors return 500 with generic message
- [ ] Database errors are logged with details

---

## üêõ Troubleshooting

### Common Issues

**1. SQLite Error: "SQLITE_CANTOPEN"**
```bash
# Solution: Check database path
echo $SQLITE_DB_PATH
ls -l ../database/sqlite/wallboard.db

# Fix permissions if needed
chmod 644 ../database/sqlite/wallboard.db
```

**2. MongoDB Error: "MongoServerError: connect ECONNREFUSED"**
```bash
# Solution: Start MongoDB service
# Windows
net start MongoDB

# macOS
brew services start mongodb-community

# Linux
sudo systemctl start mongod

# Verify
mongosh --eval "db.version()"
```

**3. Rate Limit Testing**
```bash
# Test rate limit
for i in {1..15}; do
  curl -X POST http://localhost:3001/api/auth/login \
    -H "Content-Type: application/json" \
    -d '{"agentCode": "AG001"}'
  echo ""
done
# Should see rate limit error after 10 attempts
```

**4. JWT Error: "JsonWebTokenError: invalid token"**
```javascript
// Solution: Check JWT_SECRET in .env
// Make sure it's the same across server restarts

// Generate new secret if needed
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
```

**5. CORS Error: "Access-Control-Allow-Origin"**
```javascript
// Solution: Check CORS_ORIGIN in .env
// Make sure it matches your frontend URL

// .env
CORS_ORIGIN=http://localhost:3000

// For multiple origins:
const corsOptions = {
  origin: ['http://localhost:3000', 'http://localhost:3001'],
  credentials: true
};
```

---

## üéØ API Reference Summary

### Authentication

| Method | Endpoint | Auth Required | Description |
|--------|----------|---------------|-------------|
| POST | /api/auth/login | No | Agent/Supervisor login |
| POST | /api/auth/logout | No | User logout |

### Agents

| Method | Endpoint | Auth Required | Description |
|--------|----------|---------------|-------------|
| GET | /api/agents/team/:teamId | Yes | Get team members |
| PUT | /api/agents/:agentCode/status | Yes | Update agent status |
| GET | /api/agents/:agentCode/history | Yes | Get status history |

### Messages

| Method | Endpoint | Auth Required | Description |
|--------|----------|---------------|-------------|
| POST | /api/messages/send | Yes | Send message |
| GET | /api/messages/agent/:agentCode | Yes | Get messages |
| PUT | /api/messages/:messageId/read | Yes | Mark as read |

### WebSocket Events

**Client ‚Üí Server:**
- `agent_connect` - Agent authentication
- `supervisor_connect` - Supervisor authentication
- `update_status` - Status change
- `send_message` - Send message

**Server ‚Üí Client:**
- `connection_success` - Auth successful
- `agent_status_update` - Status changed
- `new_message` - Message received
- `agent_connected` - Agent online
- `agent_disconnected` - Agent offline

---

## üìö Next Steps

‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å Backend ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏•‡πâ‡∏ß:

1. ‚úÖ **Backend Server ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô**
2. ‚è≠Ô∏è **[6.6.3.1 Frontend - Electron Agent App](./6.6.3.1-Frontend-Applications-Electron-Agent-App.md)** - ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Agent Desktop App
3. ‚è≠Ô∏è **[6.6.3.2 Frontend - Supervisor Dashboard](./6.6.3.2-Frontend-Applications-Supervisor-Dashboard.md)** - ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Supervisor Web Dashboard

### ‡∏Å‡∏≤‡∏£ Run ‡∏ó‡∏±‡πâ‡∏á‡∏£‡∏∞‡∏ö‡∏ö

```bash
# Terminal 1: Start Backend
cd backend-server
npm run dev

# Terminal 2: Start Agent Desktop (coming next)
cd agent-desktop
npm run electron-dev

# Terminal 3: Start Supervisor Dashboard (coming next)
cd supervisor-dashboard
npm start
```

**üöÄ Backend Server v2.0 ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏•‡πâ‡∏ß! ‡∏ï‡πà‡∏≠‡πÑ‡∏õ: Frontend Development**