# 6.6.3.1 Frontend - Electron Agent Desktop App (Complete Version V3)

## 🎯 ภาพรวม

เอกสารนี้อธิบายโครงสร้างและการพัฒนา **Agent Desktop Application** ที่สร้างด้วย **Electron.js + React** สำหรับระบบ Agent Wallboard System โดย App นี้จะเชื่อมต่อกับ Backend v2.0 อย่างสมบูรณ์ และใช้ข้อมูลจาก Database Schema ที่กำหนด

**เวอร์ชัน:** 3.0 (Complete Integration - แก้ไขและเพิ่มเติมทุกจุดที่ขาดหาย)

### 🎓 เป้าหมายการเรียนรู้
- เข้าใจโครงสร้าง Electron + React Application
- รู้วิธีเชื่อมต่อ Backend API แบบสมบูรณ์
- เข้าใจการทำงานของ WebSocket real-time
- รู้วิธีจัดการ authentication tokens
- เข้าใจ error handling และ fallback mechanisms
- สามารถทดสอบและ debug Application ได้

---

## 🏗️ Application Architecture

### 📁 Project Structure

```
agent-desktop/
├── 📦 package.json                 # Dependencies และ scripts
├── 🔧 .env.example                 # Environment template
├── ⚡ main.js                      # Electron main process
├── 🔒 preload.js                   # Security bridge
│
├── 📝 public/
│   ├── index.html                  # HTML template
│   └── assets/
│       ├── icon.png                # App icon (256x256)
│       └── tray-icon.png           # Tray icon (16x16)
│
└── ⚛️ src/                          # React Application
    ├── App.js                      # Main component (UPDATED)
    ├── index.js                    # React entry
    │
    ├── components/
    │   ├── LoginForm.js            # Login interface (UPDATED)
    │   ├── AgentInfo.js            # Agent information display
    │   ├── StatusPanel.js          # Status control buttons
    │   └── MessagePanel.js         # Message display (UPDATED)
    │
    ├── services/
    │   ├── api.js                  # HTTP API calls (UPDATED - Complete)
    │   ├── socket.js               # WebSocket connection (UPDATED)
    │   └── notifications.js        # Desktop notifications
    │
    ├── utils/
    │   ├── dateUtils.js            # Date formatting
    │   └── validation.js           # Input validation
    │
    └── styles/
        ├── App.css                 # Main styles
        └── components.css          # Component styles (UPDATED)
```

---

## 📦 Setup & Installation

### Step 1: Initialize Project

```bash
# Create directory
mkdir agent-desktop
cd agent-desktop

# Initialize npm
npm init -y

# Install dependencies
npm install react react-dom react-scripts socket.io-client

# Install Electron
npm install --save-dev electron concurrently wait-on electron-builder
```

### Step 2: Create package.json

```json
{
  "name": "agent-wallboard-desktop",
  "version": "3.0.0",
  "description": "Agent Desktop Application for Wallboard System - Complete Version",
  "main": "main.js",
  "homepage": "./",
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "electron": "electron .",
    "electron-dev": "concurrently \"npm start\" \"wait-on http://localhost:3000 && electron .\"",
    "dist": "npm run build && electron-builder"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "socket.io-client": "^4.7.2"
  },
  "devDependencies": {
    "electron": "^28.0.0",
    "concurrently": "^8.2.0",
    "wait-on": "^7.0.1",
    "electron-builder": "^24.6.3"
  },
  "browserslist": {
    "production": [">0.2%", "not dead", "not op_mini all"],
    "development": ["last 1 chrome version", "last 1 firefox version"]
  }
}
```

### Step 3: Create .env File

```bash
# API Configuration
REACT_APP_API_URL=http://localhost:3001/api
REACT_APP_SOCKET_URL=http://localhost:3001

# Development
ELECTRON_IS_DEV=true
```

---

## ⚡ Electron Main Process

### main.js

```javascript
const { app, BrowserWindow, Tray, Menu, ipcMain, Notification } = require('electron');
const path = require('path');

const isDev = process.env.ELECTRON_IS_DEV === 'true';

let mainWindow;
let tray;

// IPC Handlers
ipcMain.handle('show-notification', async (event, { title, body }) => {
  try {
    const notification = new Notification({ title, body });
    notification.show();
    return { success: true };
  } catch (error) {
    console.error('Notification error:', error);
    return { success: false, error: error.message };
  }
});

ipcMain.handle('minimize-to-tray', () => {
  if (mainWindow) mainWindow.hide();
});

ipcMain.handle('show-app', () => {
  if (mainWindow) {
    mainWindow.show();
    mainWindow.focus();
  }
});

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 400,
    height: 700,
    minWidth: 350,
    minHeight: 600,
    icon: path.join(__dirname, 'public/assets/icon.png'),
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    },
    show: false,
    resizable: true,
    maximizable: false
  });

  // Load app
  const startUrl = isDev 
    ? 'http://localhost:3000' 
    : `file://${path.join(__dirname, 'build/index.html')}`;
  
  mainWindow.loadURL(startUrl);

  mainWindow.once('ready-to-show', () => {
    mainWindow.show();
    if (isDev) mainWindow.webContents.openDevTools();
  });

  // Minimize to tray instead of close
  mainWindow.on('close', (event) => {
    if (!app.isQuiting) {
      event.preventDefault();
      mainWindow.hide();
    }
  });
}

function createTray() {
  try {
    tray = new Tray(path.join(__dirname, 'public/assets/tray-icon.png'));
    
    const contextMenu = Menu.buildFromTemplate([
      { 
        label: 'Show App', 
        click: () => {
          mainWindow.show();
          mainWindow.focus();
        }
      },
      { type: 'separator' },
      { 
        label: 'Quit', 
        click: () => {
          app.isQuiting = true;
          app.quit();
        }
      }
    ]);
    
    tray.setContextMenu(contextMenu);
    tray.setToolTip('Agent Wallboard');
    
    tray.on('double-click', () => {
      mainWindow.show();
      mainWindow.focus();
    });
  } catch (error) {
    console.error('Tray creation failed:', error);
  }
}

app.whenReady().then(() => {
  createWindow();
  createTray();
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit();
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  } else {
    mainWindow.show();
  }
});

// Prevent multiple instances
const gotTheLock = app.requestSingleInstanceLock();
if (!gotTheLock) {
  app.quit();
} else {
  app.on('second-instance', () => {
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore();
      mainWindow.focus();
    }
  });
}
```

### preload.js

```javascript
const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('electronAPI', {
  showNotification: (title, body) => {
    return ipcRenderer.invoke('show-notification', { title, body });
  },
  
  minimizeToTray: () => {
    return ipcRenderer.invoke('minimize-to-tray');
  },
  
  showApp: () => {
    return ipcRenderer.invoke('show-app');
  },
  
  isElectron: true,
  platform: process.platform
});
```

---

## 🔗 Services (UPDATED - Complete)

### services/api.js (COMPLETE VERSION)

```javascript
const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';
let authToken = null;

/**
 * Set authentication token for API calls
 */
export const setAuthToken = (token) => {
  authToken = token;
  console.log('Auth token set');
};

/**
 * Clear authentication token
 */
export const clearAuthToken = () => {
  authToken = null;
  console.log('Auth token cleared');
};

/**
 * Get current auth token
 */
export const getAuthToken = () => authToken;

/**
 * Login agent
 * @param {string} agentCode - Agent code (e.g., 'AG001')
 * @returns {Promise<Object>} Login response with user data and token
 */
export const loginAgent = async (agentCode) => {
  try {
    const response = await fetch(`${API_BASE_URL}/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ agentCode })
    });

    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Login failed');
    }
    
    // Store token
    if (data.data?.token) {
      setAuthToken(data.data.token);
    }
    
    return data;
  } catch (error) {
    console.error('Login API Error:', error);
    throw error;
  }
};

/**
 * Logout agent
 * @returns {Promise<Object>} Logout response
 */
export const logoutAgent = async () => {
  try {
    const response = await fetch(`${API_BASE_URL}/auth/logout`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`
      }
    });

    const data = await response.json();
    
    // Clear token regardless of response
    clearAuthToken();
    
    return data;
  } catch (error) {
    console.error('Logout API Error:', error);
    // Clear token even on error
    clearAuthToken();
    throw error;
  }
};

/**
 * Get messages for agent
 * @param {string} agentCode - Agent code
 * @param {number} limit - Maximum number of messages (default: 50)
 * @param {boolean} unreadOnly - Only get unread messages (default: false)
 * @returns {Promise<Object>} Messages response
 */
export const getMessages = async (agentCode, limit = 50, unreadOnly = false) => {
  try {
    if (!authToken) {
      throw new Error('Not authenticated');
    }

    const url = `${API_BASE_URL}/messages/agent/${agentCode}?limit=${limit}&unreadOnly=${unreadOnly}`;
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${authToken}`
      }
    });

    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Failed to get messages');
    }
    
    return data;
  } catch (error) {
    console.error('Get Messages API Error:', error);
    throw error;
  }
};

/**
 * Mark message as read
 * @param {string} messageId - Message ID
 * @returns {Promise<Object>} Update response
 */
export const markMessageAsRead = async (messageId) => {
  try {
    if (!authToken) {
      throw new Error('Not authenticated');
    }

    const response = await fetch(`${API_BASE_URL}/messages/${messageId}/read`, {
      method: 'PUT',
      headers: {
        'Authorization': `Bearer ${authToken}`
      }
    });

    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Failed to mark message as read');
    }
    
    return data;
  } catch (error) {
    console.error('Mark Read API Error:', error);
    throw error;
  }
};

/**
 * Update agent status via HTTP API (fallback)
 * @param {string} agentCode - Agent code
 * @param {string} status - New status
 * @returns {Promise<Object>} Update response
 */
export const updateAgentStatus = async (agentCode, status) => {
  try {
    if (!authToken) {
      throw new Error('Not authenticated');
    }

    const response = await fetch(`${API_BASE_URL}/agents/${agentCode}/status`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`
      },
      body: JSON.stringify({ status })
    });

    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Failed to update status');
    }
    
    return data;
  } catch (error) {
    console.error('Update Status API Error:', error);
    throw error;
  }
};

/**
 * Get agent status history
 * @param {string} agentCode - Agent code
 * @param {number} limit - Maximum number of records (default: 50)
 * @returns {Promise<Object>} Status history response
 */
export const getStatusHistory = async (agentCode, limit = 50) => {
  try {
    if (!authToken) {
      throw new Error('Not authenticated');
    }

    const response = await fetch(`${API_BASE_URL}/agents/${agentCode}/history?limit=${limit}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${authToken}`
      }
    });

    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Failed to get status history');
    }
    
    return data;
  } catch (error) {
    console.error('Get Status History API Error:', error);
    throw error;
  }
};

/**
 * Check server health
 * @returns {Promise<Object>} Health check response
 */
export const checkServerHealth = async () => {
  try {
    const response = await fetch(`${API_BASE_URL.replace('/api', '')}/health`, {
      method: 'GET'
    });

    const data = await response.json();
    
    if (!response.ok) {
      throw new Error('Server health check failed');
    }
    
    return data;
  } catch (error) {
    console.error('Health Check Error:', error);
    throw error;
  }
};
```

### services/socket.js (UPDATED)

```javascript
import io from 'socket.io-client';

const SOCKET_URL = process.env.REACT_APP_SOCKET_URL || 'http://localhost:3001';
let socket = null;

/**
 * Connect to WebSocket server
 * @param {string} agentCode - Agent code
 * @returns {Object} Socket instance
 */
export const connectSocket = (agentCode) => {
  if (socket) disconnectSocket();

  console.log('Connecting to WebSocket...', SOCKET_URL);

  socket = io(SOCKET_URL, {
    query: { 
      agentCode: agentCode.toUpperCase(), 
      type: 'agent' 
    },
    timeout: 20000,
    reconnection: true,
    reconnectionAttempts: 5,
    reconnectionDelay: 1000,
    reconnectionDelayMax: 5000
  });

  // Connection events
  socket.on('connect', () => {
    console.log('WebSocket connected:', socket.id);
    socket.emit('agent_connect', { agentCode: agentCode.toUpperCase() });
  });

  socket.on('disconnect', (reason) => {
    console.log('WebSocket disconnected:', reason);
  });

  socket.on('connect_error', (error) => {
    console.error('WebSocket connection error:', error);
  });

  socket.on('reconnect', (attemptNumber) => {
    console.log('WebSocket reconnected after', attemptNumber, 'attempts');
  });

  socket.on('reconnect_error', (error) => {
    console.error('WebSocket reconnection error:', error);
  });

  socket.on('reconnect_failed', () => {
    console.error('WebSocket reconnection failed after all attempts');
  });

  // Error events
  socket.on('connection_error', (error) => {
    console.error('Connection error from server:', error);
  });

  socket.on('status_error', (error) => {
    console.error('Status update error from server:', error);
  });

  socket.on('message_error', (error) => {
    console.error('Message error from server:', error);
  });

  // Make socket available globally for debugging
  window.socket = socket;
  
  return socket;
};

/**
 * Disconnect from WebSocket server
 */
export const disconnectSocket = () => {
  if (socket) {
    console.log('Disconnecting WebSocket...');
    socket.disconnect();
    socket = null;
    window.socket = null;
  }
};

/**
 * Send status update via WebSocket
 * @param {string} agentCode - Agent code
 * @param {string} status - New status
 * @returns {boolean} Success status
 */
export const sendStatusUpdate = (agentCode, status) => {
  if (socket && socket.connected) {
    console.log('Sending status update via WebSocket:', { agentCode, status });
    socket.emit('update_status', {
      agentCode: agentCode.toUpperCase(),
      status: status
    });
    return true;
  }
  console.warn('Socket not connected, cannot send status update');
  return false;
};

/**
 * Get socket connection status
 * @returns {boolean} Connection status
 */
export const isSocketConnected = () => {
  return socket && socket.connected;
};

/**
 * Get socket instance
 * @returns {Object|null} Socket instance
 */
export const getSocket = () => socket;
```

### services/notifications.js

```javascript
/**
 * Show desktop notification
 * @param {string} title - Notification title
 * @param {string} body - Notification body
 */
export const showDesktopNotification = async (title, body) => {
  try {
    // Try Electron API first
    if (window.electronAPI && window.electronAPI.showNotification) {
      await window.electronAPI.showNotification(title, body);
      return;
    }
    
    // Fallback to browser Notification API
    if ('Notification' in window && Notification.permission === 'granted') {
      new Notification(title, {
        body,
        icon: '/assets/icon.png',
        badge: '/assets/tray-icon.png'
      });
    }
  } catch (error) {
    console.error('Notification error:', error);
  }
};

/**
 * Request notification permission
 * @returns {Promise<string>} Permission status
 */
export const requestNotificationPermission = async () => {
  if ('Notification' in window && Notification.permission === 'default') {
    const permission = await Notification.requestPermission();
    console.log('Notification permission:', permission);
    return permission;
  }
  return Notification.permission;
};
```

---

## ⚛️ React Application (UPDATED)

### src/App.js (UPDATED - Complete Integration)

```javascript
import React, { useState, useEffect, useCallback } from 'react';
import LoginForm from './components/LoginForm';
import AgentInfo from './components/AgentInfo';
import StatusPanel from './components/StatusPanel';
import MessagePanel from './components/MessagePanel';
import { 
  setAuthToken, 
  getMessages, 
  updateAgentStatus,
  logoutAgent 
} from './services/api';
import { 
  connectSocket, 
  disconnectSocket, 
  sendStatusUpdate,
  isSocketConnected 
} from './services/socket';
import { 
  showDesktopNotification, 
  requestNotificationPermission 
} from './services/notifications';
import './styles/App.css';
import './styles/components.css';

function App() {
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  const [agent, setAgent] = useState(null);
  const [status, setStatus] = useState('Offline');
  const [messages, setMessages] = useState([]);
  const [connectionStatus, setConnectionStatus] = useState('disconnected');
  const [error, setError] = useState(null);
  const [loadingMessages, setLoadingMessages] = useState(false);

  // Request notification permission on start
  useEffect(() => {
    requestNotificationPermission();
  }, []);

  // Load existing messages when logged in
  const loadMessages = useCallback(async (agentCode) => {
    setLoadingMessages(true);
    try {
      console.log('Loading existing messages for', agentCode);
      const messagesData = await getMessages(agentCode, 50);
      
      if (messagesData.success) {
        const messageList = messagesData.messages || [];
        console.log('Loaded', messageList.length, 'messages');
        setMessages(messageList);
      }
    } catch (error) {
      console.error('Failed to load messages:', error);
      // Don't show error for message loading failure
    } finally {
      setLoadingMessages(false);
    }
  }, []);

  // WebSocket connection management
  useEffect(() => {
    if (isLoggedIn && agent) {
      const socket = connectSocket(agent.agentCode);
      
      if (socket) {
        // Connection status handlers
        socket.on('connect', () => {
          console.log('Connected to server');
          setConnectionStatus('connected');
          setError(null);
        });
        
        socket.on('disconnect', () => {
          console.log('Disconnected from server');
          setConnectionStatus('disconnected');
        });
        
        socket.on('connect_error', (error) => {
          console.error('Connection error:', error);
          setConnectionStatus('error');
          setError('Failed to connect to server');
        });

        socket.on('reconnect', (attemptNumber) => {
          console.log('Reconnected after', attemptNumber, 'attempts');
          setConnectionStatus('connected');
          setError(null);
        });
        
        // Authentication response
        socket.on('connection_success', (data) => {
          console.log('WebSocket authentication successful:', data);
        });

        socket.on('connection_error', (error) => {
          console.error('Connection error from server:', error);
          setError(error.message || 'Connection error');
        });
        
        // Status update handlers
        socket.on('status_updated', (data) => {
          console.log('Status updated:', data);
          setStatus(data.status);
        });

        socket.on('status_error', (error) => {
          console.error('Status error from server:', error);
          setError(error.message || 'Status update failed');
        });
        
        // Message handlers
        socket.on('new_message', (message) => {
          console.log('New message received:', message);
          
          // Add to messages list
          setMessages(prev => [message, ...prev]);
          
          // Show notification
          showDesktopNotification(
            `Message from ${message.fromCode}`,
            message.content
          );
        });

        socket.on('message_sent', (data) => {
          console.log('Message sent confirmation:', data);
        });

        socket.on('message_error', (error) => {
          console.error('Message error from server:', error);
        });
        
        // Agent presence handlers
        socket.on('agent_connected', (data) => {
          console.log('Agent connected:', data);
        });

        socket.on('agent_disconnected', (data) => {
          console.log('Agent disconnected:', data);
        });
      }
    }
    
    return () => {
      disconnectSocket();
      setConnectionStatus('disconnected');
    };
  }, [isLoggedIn, agent]);

  /**
   * Handle successful login
   */
  const handleLogin = async (agentData, token) => {
    console.log('Login successful:', agentData);
    
    // Set authentication token
    setAuthToken(token);
    
    // Set agent data and login state
    setAgent(agentData);
    setIsLoggedIn(true);
    setStatus('Available');
    setError(null);
    
    // Load existing messages
    await loadMessages(agentData.agentCode);
  };

  /**
   * Handle logout
   */
  const handleLogout = async () => {
    try {
      // Call logout API
      await logoutAgent();
    } catch (error) {
      console.error('Logout API call failed:', error);
    }
    
    // Disconnect WebSocket
    disconnectSocket();
    
    // Reset state
    setIsLoggedIn(false);
    setAgent(null);
    setStatus('Offline');
    setMessages([]);
    setConnectionStatus('disconnected');
    setError(null);
  };

  /**
   * Handle status change with fallback mechanism
   */
  const handleStatusChange = async (newStatus) => {
    if (!agent) return;
    
    console.log('Changing status to:', newStatus);
    
    // Optimistically update UI
    const previousStatus = status;
    setStatus(newStatus);
    
    try {
      // Method 1: Try WebSocket first (real-time)
      const socketSuccess = sendStatusUpdate(agent.agentCode, newStatus);
      
      if (socketSuccess) {
        console.log('Status update sent via WebSocket');
      } else {
        // Method 2: Fallback to HTTP API
        console.log('WebSocket not connected, using HTTP API fallback');
        await updateAgentStatus(agent.agentCode, newStatus);
        console.log('Status updated via HTTP API');
      }
    } catch (error) {
      console.error('Status update failed:', error);
      
      // Revert to previous status on error
      setStatus(previousStatus);
      setError('Failed to update status. Please try again.');
      
      // Clear error after 3 seconds
      setTimeout(() => setError(null), 3000);
    }
  };

  /**
   * Clear error message
   */
  const clearError = () => setError(null);

  return (
    <div className="app">
      {/* Connection Status */}
      <div className={`connection-status ${connectionStatus}`}>
        <div className="status-indicator"></div>
        <span>
          {connectionStatus === 'connected' && 'Connected'}
          {connectionStatus === 'disconnected' && 'Disconnected'}
          {connectionStatus === 'error' && 'Connection Error'}
        </span>
      </div>

      {/* Error Banner */}
      {error && (
        <div className="error-banner">
          <span>{error}</span>
          <button onClick={clearError} className="error-close">×</button>
        </div>
      )}

      {/* Main Content */}
      {!isLoggedIn ? (
        <LoginForm onLogin={handleLogin} />
      ) : (
        <div className="dashboard">
          <div className="dashboard-header">
            <AgentInfo agent={agent} status={status} />
            <button onClick={handleLogout} className="logout-btn">
              Logout
            </button>
          </div>
          
          <StatusPanel 
            currentStatus={status} 
            onStatusChange={handleStatusChange}
            disabled={connectionStatus !== 'connected'}
          />
          
          <MessagePanel 
            messages={messages}
            agentCode={agent?.agentCode}
            loading={loadingMessages}
          />
        </div>
      )}
    </div>
  );
}

export default App;
```

### src/index.js

```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

---

## 🧩 React Components (UPDATED)

### components/LoginForm.js (UPDATED)

```javascript
import React, { useState } from 'react';
import { loginAgent, checkServerHealth } from '../services/api';
import { validateAgentCode } from '../utils/validation';

function LoginForm({ onLogin }) {
  const [agentCode, setAgentCode] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [serverStatus, setServerStatus] = useState('unknown');

  // Check server health on mount
  React.useEffect(() => {
    checkHealth();
  }, []);

  const checkHealth = async () => {
    try {
      await checkServerHealth();
      setServerStatus('online');
    } catch (error) {
      setServerStatus('offline');
      setError('Backend server is not running. Please start the server first.');
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    // Validate agent code
    const validationError = validateAgentCode(agentCode);
    if (validationError) {
      setError(validationError);
      return;
    }

    setLoading(true);
    setError('');

    try {
      const result = await loginAgent(agentCode.toUpperCase());
      
      if (result.success) {
        // Pass both user data and token to parent
        onLogin(result.data.user, result.data.token);
      } else {
        setError(result.error || 'Login failed');
      }
    } catch (err) {
      console.error('Login error:', err);
      
      if (err.message.includes('fetch')) {
        setError('Cannot connect to server. Please check if backend is running.');
        setServerStatus('offline');
      } else {
        setError(err.message || 'Network error. Please check your connection.');
      }
    } finally {
      setLoading(false);

  }

  const handleRetry = () => {
    setError('');
    checkHealth();
  };

  return (
    <div className="login-container">
      <div className="login-form">
        <div className="login-header">
          <h2>Agent Login</h2>
          <p>Enter your agent code to continue</p>
          
          {/* Server Status Indicator */}
          <div className={`server-status ${serverStatus}`}>
            <span className="status-dot"></span>
            <span>Server: {serverStatus}</span>
          </div>
        </div>
        
        <form onSubmit={handleSubmit}>
          <div className="form-group">
            <label htmlFor="agentCode">Agent Code</label>
            <input
              id="agentCode"
              type="text"
              placeholder="e.g., AG001"
              value={agentCode}
              onChange={(e) => {
                setAgentCode(e.target.value.toUpperCase());
                if (error) setError('');
              }}
              disabled={loading || serverStatus === 'offline'}
              maxLength={5}
              autoFocus
            />
          </div>
          
          <button 
            type="submit" 
            disabled={loading || !agentCode.trim() || serverStatus === 'offline'}
            className="login-btn"
          >
            {loading ? 'Signing in...' : 'Sign In'}
          </button>
          
          {error && (
            <div className="error-message">
              <span>⚠️</span> {error}
              {serverStatus === 'offline' && (
                <button 
                  type="button" 
                  onClick={handleRetry} 
                  className="retry-btn"
                >
                  Retry Connection
                </button>
              )}
            </div>
          )}
        </form>
        
        <div className="login-footer">
          <p>Sample codes: AG001, AG002, AG003</p>
          <p className="help-text">
            Need help? Check if backend server is running on port 3001
          </p>
        </div>
      </div>
    </div>
  );
}

export default LoginForm;
```

### components/AgentInfo.js

```javascript
import React from 'react';

function AgentInfo({ agent, status }) {
  if (!agent) return null;

  const getStatusColor = (status) => {
    const colors = {
      Available: '#4CAF50',
      Busy: '#FF9800',
      Break: '#2196F3',
      Offline: '#9E9E9E'
    };
    return colors[status] || colors.Offline;
  };

  return (
    <div className="agent-info">
      <div className="agent-avatar">
        <span>👤</span>
      </div>
      
      <div className="agent-details">
        <h3 className="agent-name">{agent.agentName}</h3>
        
        <div className="agent-meta">
          <div className="agent-code">
            <span className="label">Code:</span>
            <span className="value">{agent.agentCode}</span>
          </div>
          
          <div className="agent-team">
            <span className="label">Team:</span>
            <span className="value">{agent.teamName || 'N/A'}</span>
          </div>
        </div>
        
        <div className="agent-status">
          <span 
            className="status-dot"
            style={{ backgroundColor: getStatusColor(status) }}
          ></span>
          <span className="status-text">{status}</span>
        </div>
      </div>
    </div>
  );
}

export default AgentInfo;
```

### components/StatusPanel.js

```javascript
import React from 'react';

function StatusPanel({ currentStatus, onStatusChange, disabled = false }) {
  const statuses = [
    { key: 'Available', label: 'Available', color: '#4CAF50', icon: '✓' },
    { key: 'Busy', label: 'Busy', color: '#FF9800', icon: '⏱' },
    { key: 'Break', label: 'Break', color: '#2196F3', icon: '☕' },
    { key: 'Offline', label: 'Offline', color: '#9E9E9E', icon: '⏸' }
  ];

  return (
    <div className="status-panel">
      <div className="status-header">
        <h3>Status Control</h3>
        <div className="current-status">
          Current: <span className="status-badge" style={{ 
            backgroundColor: statuses.find(s => s.key === currentStatus)?.color 
          }}>
            {currentStatus}
          </span>
        </div>
      </div>
      
      <div className="status-buttons">
        {statuses.map(status => (
          <button
            key={status.key}
            className={`status-btn ${status.key === currentStatus ? 'active' : ''}`}
            onClick={() => onStatusChange(status.key)}
            disabled={disabled}
            style={{ 
              backgroundColor: status.color,
              opacity: disabled ? 0.5 : (status.key === currentStatus ? 1 : 0.8)
            }}
          >
            <span className="status-icon">{status.icon}</span>
            <span className="status-label">{status.label}</span>
          </button>
        ))}
      </div>
      
      {disabled && (
        <div className="status-warning">
          ⚠️ Not connected to server - Status updates unavailable
        </div>
      )}
    </div>
  );
}

export default StatusPanel;
```

### components/MessagePanel.js (UPDATED)

```javascript
import React, { useEffect, useRef, useState } from 'react';
import { formatTime, getTimeAgo } from '../utils/dateUtils';
import { markMessageAsRead } from '../services/api';

function MessagePanel({ messages, agentCode, loading = false }) {
  const messagesEndRef = useRef(null);
  const [markingRead, setMarkingRead] = useState(new Set());

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const handleMarkAsRead = async (messageId) => {
    if (markingRead.has(messageId)) return;

    setMarkingRead(prev => new Set(prev).add(messageId));

    try {
      await markMessageAsRead(messageId);
      console.log('Message marked as read:', messageId);
    } catch (error) {
      console.error('Failed to mark message as read:', error);
    } finally {
      setMarkingRead(prev => {
        const newSet = new Set(prev);
        newSet.delete(messageId);
        return newSet;
      });
    }
  };

  const getPriorityColor = (priority) => {
    const colors = {
      high: '#f44336',
      normal: '#2196f3',
      low: '#9e9e9e'
    };
    return colors[priority] || colors.normal;
  };

  const unreadCount = messages.filter(m => !m.isRead).length;

  return (
    <div className="message-panel">
      <div className="message-header">
        <h3>
          Messages ({messages.length})
          {unreadCount > 0 && (
            <span className="unread-badge">{unreadCount} unread</span>
          )}
        </h3>
        
        {messages.length > 0 && (
          <button 
            onClick={scrollToBottom}
            className="scroll-btn"
            title="Scroll to bottom"
          >
            ⬇️
          </button>
        )}
      </div>
      
      <div className="message-list">
        {loading ? (
          <div className="loading-messages">
            <div className="loading-spinner"></div>
            <p>Loading messages...</p>
          </div>
        ) : messages.length === 0 ? (
          <div className="no-messages">
            <div className="no-messages-icon">📭</div>
            <p>No messages yet</p>
            <small>Messages from supervisors will appear here</small>
          </div>
        ) : (
          <>
            {messages.map((message, index) => (
              <div 
                key={message._id || index}
                className={`message-item ${message.type} ${message.isRead ? 'read' : 'unread'}`}
              >
                <div className="message-top">
                  <div className="message-from">
                    <span className="from-label">From:</span>
                    <strong>{message.fromCode}</strong>
                  </div>
                  <div className="message-priority">
                    <span 
                      className="priority-indicator"
                      style={{ backgroundColor: getPriorityColor(message.priority) }}
                      title={`Priority: ${message.priority}`}
                    >
                      {message.priority === 'high' ? '🔴' : 
                       message.priority === 'low' ? '🔵' : '⚪'}
                    </span>
                  </div>
                </div>
                
                <div className="message-content">
                  {message.content}
                </div>
                
                <div className="message-footer">
                  <div className="message-meta">
                    <span className="message-type">
                      {message.type === 'broadcast' ? '📢 Broadcast' : '💬 Direct'}
                    </span>
                    <span className="message-time">
                      {formatTime(message.timestamp)}
                    </span>
                    <span className="time-ago">
                      {getTimeAgo(message.timestamp)}
                    </span>
                  </div>
                  
                  {!message.isRead && (
                    <button
                      className="mark-read-btn"
                      onClick={() => handleMarkAsRead(message._id)}
                      disabled={markingRead.has(message._id)}
                      title="Mark as read"
                    >
                      {markingRead.has(message._id) ? '⏳' : '✓'}
                    </button>
                  )}
                </div>
              </div>
            ))}
            <div ref={messagesEndRef} />
          </>
        )}
      </div>
    </div>
  );
}

export default MessagePanel;
```

---

## 🛠️ Utilities

### utils/validation.js

```javascript
/**
 * Validate agent code format
 * @param {string} code - Agent code to validate
 * @returns {string|null} Error message or null if valid
 */
export const validateAgentCode = (code) => {
  if (!code) {
    return 'Agent code is required';
  }
  
  const trimmed = code.trim().toUpperCase();
  
  if (trimmed.length === 0) {
    return 'Agent code cannot be empty';
  }
  
  // Format: AG001, SP001 (2 letters + 3 digits)
  if (!/^[A-Z]{2}\d{3}$/.test(trimmed)) {
    return 'Agent code must be in format: AG001 or SP001';
  }
  
  return null;
};

/**
 * Validate message content
 * @param {string} content - Message content
 * @returns {string|null} Error message or null if valid
 */
export const validateMessage = (content) => {
  if (!content || content.trim().length === 0) {
    return 'Message cannot be empty';
  }
  
  if (content.length > 500) {
    return 'Message is too long (max 500 characters)';
  }
  
  return null;
};
```

### utils/dateUtils.js

```javascript
/**
 * Format timestamp to HH:MM time string
 * @param {string|Date} timestamp - Timestamp to format
 * @returns {string} Formatted time (e.g., "14:30")
 */
export const formatTime = (timestamp) => {
  try {
    return new Date(timestamp).toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
  } catch {
    return '--:--';
  }
};

/**
 * Format timestamp to full date and time
 * @param {string|Date} timestamp - Timestamp to format
 * @returns {string} Formatted datetime
 */
export const formatDateTime = (timestamp) => {
  try {
    return new Date(timestamp).toLocaleString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
  } catch {
    return 'Invalid date';
  }
};

/**
 * Get relative time string (e.g., "5m ago", "2h ago")
 * @param {string|Date} timestamp - Timestamp
 * @returns {string} Relative time string
 */
export const getTimeAgo = (timestamp) => {
  try {
    const now = new Date();
    const time = new Date(timestamp);
    const diffInSeconds = Math.floor((now - time) / 1000);
    
    if (diffInSeconds < 60) {
      return 'just now';
    }
    
    const diffInMinutes = Math.floor(diffInSeconds / 60);
    if (diffInMinutes < 60) {
      return `${diffInMinutes}m ago`;
    }
    
    const diffInHours = Math.floor(diffInMinutes / 60);
    if (diffInHours < 24) {
      return `${diffInHours}h ago`;
    }
    
    const diffInDays = Math.floor(diffInHours / 24);
    if (diffInDays < 7) {
      return `${diffInDays}d ago`;
    }
    
    const diffInWeeks = Math.floor(diffInDays / 7);
    return `${diffInWeeks}w ago`;
  } catch {
    return 'unknown';
  }
};

/**
 * Calculate duration in seconds between two timestamps
 * @param {string|Date} start - Start timestamp
 * @param {string|Date} end - End timestamp
 * @returns {number} Duration in seconds
 */
export const getDuration = (start, end) => {
  try {
    const startTime = new Date(start);
    const endTime = new Date(end);
    return Math.floor((endTime - startTime) / 1000);
  } catch {
    return 0;
  }
};
```

---

## 🎨 Styles (UPDATED)

### styles/App.css

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

.app {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  max-width: 400px;
  margin: 0 auto;
  background: #f5f5f5;
  min-height: 100vh;
}

/* Connection Status Bar */
.connection-status {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  font-size: 12px;
  font-weight: 500;
  color: white;
  transition: background-color 0.3s;
}

.connection-status.connected { 
  background: #4caf50; 
}

.connection-status.disconnected { 
  background: #9e9e9e; 
}

.connection-status.error { 
  background: #f44336; 
}

.status-indicator {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: currentColor;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* Error Banner */
.error-banner {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: #f44336;
  color: white;
  padding: 12px 16px;
  font-size: 14px;
  animation: slideDown 0.3s ease-out;
}

@keyframes slideDown {
  from {
    transform: translateY(-100%);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.error-close {
  background: none;
  border: none;
  color: white;
  font-size: 20px;
  cursor: pointer;
  padding: 0;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  transition: background-color 0.2s;
}

.error-close:hover {
  background: rgba(255, 255, 255, 0.2);
}

/* Login Container */
.login-container {
  padding: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

.login-form {
  background: white;
  padding: 40px 30px;
  border-radius: 16px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.2);
  width: 100%;
  max-width: 320px;
  animation: fadeIn 0.5s ease-out;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.login-header {
  text-align: center;
  margin-bottom: 30px;
}

.login-header h2 {
  margin: 0 0 8px 0;
  color: #333;
  font-size: 24px;
}

.login-header p {
  color: #666;
  font-size: 14px;
  margin: 0;
}

/* Server Status in Login */
.server-status {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 11px;
  font-weight: 600;
  margin-top: 12px;
  text-transform: uppercase;
}

.server-status.online {
  background: #e8f5e9;
  color: #2e7d32;
}

.server-status.offline {
  background: #ffebee;
  color: #c62828;
}

.server-status.unknown {
  background: #fff3e0;
  color: #f57c00;
}

.server-status .status-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: currentColor;
}

/* Form Elements */
.form-group {
  margin-bottom: 20px;
  text-align: left;
}

.form-group label {
  display: block;
  margin-bottom: 8px;
  font-weight: 600;
  color: #333;
  font-size: 14px;
}

.form-group input {
  width: 100%;
  padding: 12px 16px;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  font-size: 16px;
  transition: border-color 0.3s;
  font-family: monospace;
  letter-spacing: 1px;
}

.form-group input:focus {
  outline: none;
  border-color: #667eea;
}

.form-group input:disabled {
  background: #f5f5f5;
  cursor: not-allowed;
}

/* Buttons */
.login-btn {
  width: 100%;
  padding: 14px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
}

.login-btn:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
}

.login-btn:active:not(:disabled) {
  transform: translateY(0);
}

.login-btn:disabled {
  background: #ccc;
  cursor: not-allowed;
  transform: none;
}

/* Error Message */
.error-message {
  margin-top: 16px;
  padding: 12px;
  background: #ffebee;
  border: 1px solid #ffcdd2;
  border-radius: 8px;
  color: #c62828;
  font-size: 13px;
  display: flex;
  align-items: flex-start;
  gap: 8px;
  animation: shake 0.5s;
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}

.error-message span {
  flex-shrink: 0;
}

.retry-btn {
  margin-top: 8px;
  padding: 6px 12px;
  background: #c62828;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 12px;
  cursor: pointer;
  width: 100%;
}

.retry-btn:hover {
  background: #b71c1c;
}

/* Login Footer */
.login-footer {
  margin-top: 20px;
  text-align: center;
}

.login-footer p {
  color: #999;
  font-size: 12px;
  margin: 6px 0;
}

.help-text {
  color: #666 !important;
  font-size: 11px !important;
}

/* Dashboard */
.dashboard {
  background: white;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.dashboard-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  border-bottom: 1px solid #e0e0e0;
  background: white;
}

.logout-btn {
  background: #f44336;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  transition: background-color 0.2s, transform 0.2s;
}

.logout-btn:hover {
  background: #d32f2f;
  transform: translateY(-1px);
}

.logout-btn:active {
  transform: translateY(0);
}

/* Loading Spinner */
.loading-spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #f3f3f3;
  border-top: 4px solid #667eea;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 0 auto 16px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
```

### styles/components.css (UPDATED)

```css
/* Agent Info Component */
.agent-info {
  display: flex;
  gap: 12px;
  flex: 1;
}

.agent-avatar {
  width: 48px;
  height: 48px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  flex-shrink: 0;
}

.agent-details {
  flex: 1;
  min-width: 0;
}

.agent-name {
  margin: 0 0 4px 0;
  font-size: 16px;
  font-weight: 600;
  color: #333;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.agent-meta {
  display: flex;
  gap: 16px;
  margin-bottom: 6px;
  font-size: 12px;
  color: #666;
}

.agent-meta > div {
  display: flex;
  gap: 4px;
}

.agent-meta .label {
  font-weight: 500;
}

.agent-meta .value {
  font-weight: 600;
  color: #333;
}

.agent-status {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 13px;
}

.agent-status .status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}

.agent-status .status-text {
  font-weight: 600;
}

/* Status Panel Component */
.status-panel {
  padding: 20px;
  border-bottom: 1px solid #e0e0e0;
  background: #fafafa;
}

.status-header {
  margin-bottom: 16px;
}

.status-header h3 {
  margin: 0 0 8px 0;
  font-size: 16px;
  font-weight: 600;
  color: #333;
}

.current-status {
  font-size: 13px;
  color: #666;
}

.status-badge {
  padding: 4px 10px;
  border-radius: 12px;
  color: white;
  font-size: 12px;
  font-weight: 600;
  margin-left: 6px;
}

.status-buttons {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

.status-btn {
  padding: 16px 12px;
  border: none;
  border-radius: 10px;
  color: white;
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.status-btn:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 4px 16px rgba(0,0,0,0.2);
}

.status-btn:active:not(:disabled) {
  transform: translateY(0);
}

.status-btn.active {
  box-shadow: 0 0 0 3px rgba(255,255,255,0.5);
  transform: scale(1.05);
}

.status-btn:disabled {
  cursor: not-allowed;
  opacity: 0.5;
}

.status-icon {
  font-size: 18px;
}

.status-label {
  font-size: 13px;
}

.status-warning {
  margin-top: 12px;
  padding: 10px;
  background: #fff3cd;
  border: 1px solid #ffc107;
  border-radius: 8px;
  color: #856404;
  font-size: 12px;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}

/* Message Panel Component */
.message-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: white;
  overflow: hidden;
}

.message-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  border-bottom: 1px solid #e0e0e0;
  background: white;
  position: sticky;
  top: 0;
  z-index: 10;
}

.message-header h3 {
  margin: 0;
  font-size: 16px;
  font-weight: 600;
  color: #333;
  display: flex;
  align-items: center;
  gap: 8px;
}

.unread-badge {
  background: #f44336;
  color: white;
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 11px;
  font-weight: 600;
}

.scroll-btn {
  background: #f0f0f0;
  border: none;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s, transform 0.2s;
}

.scroll-btn:hover {
  background: #e0e0e0;
  transform: scale(1.1);
}

.message-list {
  flex: 1;
  overflow-y: auto;
  padding: 16px 20px;
  background: #fafafa;
}

.message-list::-webkit-scrollbar {
  width: 6px;
}

.message-list::-webkit-scrollbar-track {
  background: #f1f1f1;
}

.message-list::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 3px;
}

.message-list::-webkit-scrollbar-thumb:hover {
  background: #555;
}

/* Loading Messages */
.loading-messages {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 40px 20px;
  color: #999;
}

.loading-messages p {
  margin-top: 16px;
  font-size: 14px;
}

/* No Messages */
.no-messages {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 60px 20px;
  color: #999;
  text-align: center;
}

.no-messages-icon {
  font-size: 48px;
  margin-bottom: 16px;
  opacity: 0.5;
}

.no-messages p {
  font-size: 16px;
  margin: 8px 0;
  font-weight: 500;
}

.no-messages small {
  font-size: 13px;
  color: #bbb;
}

/* Message Item */
.message-item {
  background: white;
  border: 1px solid #e9ecef;
  border-radius: 12px;
  padding: 14px;
  margin-bottom: 12px;
  transition: transform 0.2s, box-shadow 0.2s;
  animation: messageSlideIn 0.3s ease-out;
}

@keyframes messageSlideIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message-item.unread {
  border-left: 4px solid #2196f3;
  background: #e3f2fd;
  box-shadow: 0 2px 8px rgba(33, 150, 243, 0.1);
}

.message-item.broadcast {
  border-left: 4px solid #ff9800;
}

.message-item.broadcast.unread {
  background: #fff8e1;
}

.message-item:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.message-top {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.message-from {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 13px;
  color: #666;
}

.message-from strong {
  color: #333;
  font-weight: 600;
}

.message-priority {
  display: flex;
  align-items: center;
}

.priority-indicator {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
}

.message-content {
  color: #333;
  font-size: 14px;
  line-height: 1.5;
  margin-bottom: 10px;
  word-wrap: break-word;
}

.message-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.message-meta {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 11px;
  color: #999;
  flex-wrap: wrap;
}

.message-type {
  padding: 2px 6px;
  background: #f5f5f5;
  border-radius: 4px;
  font-weight: 500;
}

.message-time {
  font-weight: 500;
}

.time-ago {
  color: #bbb;
}

.mark-read-btn {
  background: #4caf50;
  color: white;
  border: none;
  border-radius: 50%;
  width: 28px;
  height: 28px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  transition: background-color 0.2s, transform 0.2s;
}

.mark-read-btn:hover:not(:disabled) {
  background: #45a049;
  transform: scale(1.1);
}

.mark-read-btn:disabled {
  background: #ccc;
  cursor: not-allowed;
}

/* Responsive Design */
@media (max-width: 350px) {
  .status-buttons {
    grid-template-columns: 1fr;
  }
  
  .agent-meta {
    flex-direction: column;
    gap: 4px;
  }
}
```

---

## 🧪 Testing Guide (UPDATED)

### Complete Testing Checklist

#### 1. Backend Preparation

```bash
# Terminal 1: Start Backend Server
cd backend-server
npm run dev

# Verify backend is running
curl http://localhost:3001/health
```

Expected response:
```json
{
  "status": "OK",
  "timestamp": "2024-01-15T10:00:00.000Z",
  "uptime": 123.456
}
```

#### 2. Start Agent Desktop App

```bash
# Terminal 2: Start Electron App
cd agent-desktop
npm run electron-dev
```

#### 3. Test Login Flow

**Test Case 1: Successful Login**
```
Input: AG001
Expected: 
- Login successful
- Dashboard appears
- Agent info displays correctly
- WebSocket connects (green status bar)
- Existing messages load
```

**Test Case 2: Invalid Code Format**
```
Input: ABC (wrong format)
Expected: Validation error message
```

**Test Case 3: Invalid Credentials**
```
Input: AG999 (non-existent)
Expected: "Invalid credentials" error
```

**Test Case 4: Backend Offline**
```
Action: Stop backend server, try login
Expected: 
- Red server status indicator
- "Backend server is not running" error
- Retry button appears
```

#### 4. Test Status Changes

**Test Case 5: Status Update via WebSocket**
```
Action: Click "Busy" button
Expected:
- UI updates immediately
- Backend logs show status update
- Supervisor dashboard shows change (if running)
```

**Test Case 6: Status Update when Disconnected**
```
Action: 
1. Disconnect backend
2. Try changing status
Expected:
- Fallback to HTTP API
- Error if both methods fail
- Status reverts if update fails
```

#### 5. Test Message Reception

**Test Case 7: Receive Direct Message**
```
Using Postman or curl:
POST http://localhost:3001/api/messages/send
{
  "fromCode": "SP001",
  "toCode": "AG001",
  "content": "Test direct message",
  "type": "direct",
  "priority": "normal"
}

Expected:
- Message appears in message panel
- Desktop notification shows
- Unread count increases
```

**Test Case 8: Receive Broadcast Message**
```
POST http://localhost:3001/api/messages/send
{
  "fromCode": "SP001",
  "toTeamId": 1,
  "content": "Team announcement",
  "type": "broadcast",
  "priority": "high"
}

Expected:
- Message appears for all team members
- Red priority indicator shows
- Broadcast icon displays
```

**Test Case 9: Mark Message as Read**
```
Action: Click checkmark button on unread message
Expected:
- Message background changes
- Unread badge count decreases
- Backend updates isRead flag
```

#### 6. Test WebSocket Reconnection

**Test Case 10: Server Restart**
```
Action:
1. Login successfully
2. Stop backend server
3. Restart backend server

Expected:
- Connection status shows "disconnected"
- Automatic reconnection after ~5 seconds
- Connection status shows "connected"
- Status updates work again
```

#### 7. Test Load Existing Messages

**Test Case 11: Login with Message History**
```
Action:
1. Send messages via API first
2. Login as AG001

Expected:
- All existing messages load
- Messages sorted by timestamp
- Unread messages highlighted
```

### Automated Test Script

Create `test-agent-app.js`:

```javascript
const fetch = require('node-fetch');

const API_URL = 'http://localhost:3001/api';
let authToken = null;

async function runTests() {
  console.log('🧪 Running Agent Desktop App Tests\n');
  
  try {
    // Test 1: Health Check
    console.log('Test 1: Backend Health Check');
    const health = await fetch('http://localhost:3001/health');
    const healthData = await health.json();
    console.log('✅ Backend is running:', healthData.status);
    console.log('');
    
    // Test 2: Agent Login
    console.log('Test 2: Agent Login');
    const loginRes = await fetch(`${API_URL}/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ agentCode: 'AG001' })
    });
    const loginData = await loginRes.json();
    
    if (loginData.success) {
      authToken = loginData.data.token;
      console.log('✅ Login successful');
      console.log('   Agent:', loginData.data.user.agentName);
      console.log('   Token:', authToken.substring(0, 20) + '...');
    } else {
      console.log('❌ Login failed:', loginData.error);
      return;
    }
    console.log('');
    
    // Test 3: Get Existing Messages
    console.log('Test 3: Get Existing Messages');
    const messagesRes = await fetch(`${API_URL}/messages/agent/AG001`, {
      headers: { 'Authorization': `Bearer ${authToken}` }
    });
    const messagesData = await messagesRes.json();
    
    if (messagesData.success) {
      console.log('✅ Messages loaded:', messagesData.count);
      if (messagesData.messages.length > 0) {
        console.log('   Latest:', messagesData.messages[0].content.substring(0, 50));
      }
    } else {
      console.log('❌ Failed to load messages');
    }
    console.log('');
    
    // Test 4: Send Test Message
    console.log('Test 4: Send Test Message');
    const messageRes = await fetch(`${API_URL}/messages/send`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`
      },
      body: JSON.stringify({
        fromCode: 'SP001',
        toCode: 'AG001',
        content: 'Automated test message',
        type: 'direct',
        priority: 'normal'
      })
    });
    const messageData = await messageRes.json();
    
    if (messageData.success) {
      console.log('✅ Test message sent');
      console.log('   Message ID:', messageData.data.messageId);
    } else {
      console.log('❌ Failed to send message');
    }
    console.log('');
    
    // Test 5: Update Status
    console.log('Test 5: Update Agent Status');
    const statusRes = await fetch(`${API_URL}/agents/AG001/status`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${authToken}`
      },
      body: JSON.stringify({ status: 'Busy' })
    });
    const statusData = await statusRes.json();
    
    if (statusData.success) {
      console.log('✅ Status updated to:', statusData.data.status);
    } else {
      console.log('❌ Failed to update status');
    }
    console.log('');
    
    // Test 6: Get Status History
    console.log('Test 6: Get Status History');
    const historyRes = await fetch(`${API_URL}/agents/AG001/history`, {
      headers: { 'Authorization': `Bearer ${authToken}` }
    });
    const historyData = await historyRes.json();
    
    if (historyData.success) {
      console.log('✅ Status history loaded:', historyData.count, 'records');
      if (historyData.history.length > 0) {
        console.log('   Latest:', historyData.history[0].status);
      }
    } else {
      console.log('❌ Failed to load history');
    }
    console.log('');
    
    console.log('✅ All tests completed!');
    console.log('\nNow open the Electron app and test:');
    console.log('1. Login with AG001');
    console.log('2. Check if messages appear');
    console.log('3. Try changing status');
    console.log('4. Check desktop notifications');
    
  } catch (error) {
    console.error('❌ Test error:', error.message);
  }
}

runTests();
```

Run tests:
```bash
cd agent-desktop
node test-agent-app.js
```

---

## ✅ Complete Verification Checklist

### Setup Verification
- [ ] package.json has all dependencies
- [ ] .env file created with correct URLs
- [ ] Backend server running on port 3001
- [ ] MongoDB service running
- [ ] SQLite database has sample data

### Login Features
- [ ] Login form displays correctly
- [ ] Server status indicator works
- [ ] Agent code validation works
- [ ] Successful login loads dashboard
- [ ] Token stored and used in API calls
- [ ] Invalid credentials show error
- [ ] Backend offline shows appropriate message

### Dashboard Features
- [ ] Agent info displays correctly
- [ ] Status indicator shows current status
- [ ] All 4 status buttons present and clickable
- [ ] Logout button works

### Real-time Communication
- [ ] WebSocket connects automatically after login
- [ ] Connection status indicator accurate
- [ ] Status changes update immediately
- [ ] Status update fallback to HTTP works
- [ ] Messages received in real-time
- [ ] Desktop notifications appear
- [ ] Unread badge updates correctly

### Message Features
- [ ] Existing messages load on login
- [ ] Messages display with correct info
- [ ] Direct/broadcast icons show
- [ ] Priority indicators display
- [ ] Time formatting works
- [ ] Scroll to bottom works
- [ ] Mark as read button works
- [ ] Unread count accurate

### Error Handling
- [ ] Network errors handled gracefully
- [ ] Token expiration handled
- [ ] WebSocket disconnection handled
- [ ] API errors show user-friendly messages
- [ ] Errors can be dismissed

### Electron Features
- [ ] App opens in correct window size
- [ ] System tray icon appears
- [ ] Minimize to tray works
- [ ] Double-click tray restores window
- [ ] Single instance enforcement works
- [ ] Quit from tray works

---

## 📚 Summary of Changes from V2 to V3

### New Features Added

1. **Complete API Service** (`services/api.js`)
   - Added `getMessages()` - Load existing messages
   - Added `markMessageAsRead()` - Mark messages as read
   - Added `updateAgentStatus()` - HTTP fallback for status
   - Added `getStatusHistory()` - View status history
   - Added `checkServerHealth()` - Server health check
   - Added token management functions

2. **Enhanced App.js**
   - Load existing messages on login
   - HTTP fallback for status updates
   - Better error handling
   - Token management
   - Loading states

3. **Improved LoginForm**
   - Server status indicator
   - Health check on mount
   - Retry connection button
   - Better error messages

4. **Enhanced MessagePanel**
   - Mark as read functionality
   - Priority indicators
   - Unread count badge
   - Loading state
   - Better message styling

5. **Updated Socket.js**
   - More error event handlers
   - Connection status helpers
   - Better logging

6. **Improved Styles**
   - Unread message highlighting
   - Priority color coding
   - Loading animations
   - Better responsive design
   - Server status indicators

### Bug Fixes

1. Token not being stored and used
2. Messages not loading on login
3. No HTTP fallback for status updates
4. Missing mark as read feature
5. No loading states
6. Missing error handlers

---

## 🎯 Next Steps

1. ✅ **Agent Desktop App V3 Complete**
2. ⏭️ **[6.6.3.2 Supervisor Dashboard](./6.6.3.2-Frontend-Applications-Supervisor-Dashboard.md)** - Web interface for supervisors
3. ⏭️ **Integration Testing** - Test complete system together

### Enhancement Ideas for Students

**Phase 1 (Easy):**
- Add sound effects for new messages
- Change app theme colors
- Add keyboard shortcuts (Ctrl+1/2/3/4 for status)

**Phase 2 (Medium):**
- Add message search/filter
- Add status history view
- Add notification settings
- Add dark mode

**Phase 3 (Advanced):**
- Add message templates
- Add file attachments
- Add typing indicators
- Add message reactions

---

**🎉 Agent Desktop App V3.0 Complete! พร้อมใช้งานเต็มรูปแบบแล้ว!**
